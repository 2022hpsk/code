{
  "sql1": "Q: \"统计各个玩法上线首周留存情况\n输出：玩法、上线首周首次玩的日期、第几天留存（0,1,2...7)、玩法留存用户数\n\n各玩法首周上线日期：\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename,dws_jordass_mode_roundrecord_di.mapname]\nA: Let’s think step by step. The SQL query for the question \"统计各个玩法上线首周留存情况...\" needs these tables = [dws_jordass_mode_roundrecord_di], so we only reference a single base table but will use multiple derived subqueries and unions to separate modes.\nPlus, it requires nested/derived queries and UNION ALL across mode-specific selections to build per-mode first-play dates and per-mode daily activity windows, and then a join between those derived results to compute day-diff retention; the sub-questions needed = [\"对于每个玩法和每个玩家，在该玩法上线首周内的首次玩的日期是什么？\",\"对于每个玩法，在首周后第0~7天哪些玩家有行为？\"].\nSo, we need derived subqueries (UNION ALL) and a LEFT JOIN between derived sets, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql2": "Q: \"统计2019.5.8至2025.3.30 分月的玩法主玩情况\n输出：月份(201905、201906、...、202503)、主玩玩法、主玩人数、总参与人数\"\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.roundtime,dwd_jordass_playerexitgamerecord_hi.tdbank_imp_date,dwd_jordass_playerexitgamerecord_hi.mode]\nA: Let’s think step by step. The SQL query for the question \"统计2019.5.8至2025.3.30 分月的玩法主玩情况...\" needs these tables = [dws_jordass_mode_roundrecord_di, dwd_jordass_playerexitgamerecord_hi], so we need to combine data from two tables (UNION ALL) and aggregate per player-month-mode.\nPlus, it requires intermediate aggregation per (mons, vplayerid, mode) to compute total roundtime/roundcnt and then windowing (row_number) to pick each player's main mode per month; the sub-question needed = [\"对于每个玩家每个月，计算其在每个玩法的累计时长与对局数以确定主玩玩法。\"].\nSo, we need CTE/aggregation + row_number windowing and UNION of sources, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql3": "Q: \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数（去重）有多少，其中多少人是12月13日及以前有参与过建筑争夺的老玩家，有多少是新玩家\n输出: 玩家人数、老玩家人数、新玩家人数\"\nschema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_playermatchrecord_stat_df.dtstatdate,dws_jordass_playermatchrecord_stat_df.vplayerid]\nA: Let’s think step by step. The SQL query for the question \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数...\" needs these tables = [dws_jordass_matchlog_stat_di, dws_jordass_playermatchrecord_stat_df], so we need JOIN between the set of players in the target window and the set of players who played earlier.\nPlus, it requires a subquery to identify the target-window distinct players and a subquery to identify prior players (on 20241213 or earlier), then a LEFT JOIN to count existing vs new; the sub-question needed = [\"在2024-12-14到2024-12-20期间，哪些玩家参与了建筑争夺？\",\"在2024-12-13及以前，哪些玩家曾参与建筑争夺？\"].\nSo, we need subqueries and LEFT JOIN/EXCEPT-style logic, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\""
}