{
  "sql28": "Q: \"统计各个玩法上线首周留存情况\n输出：玩法、上线首周首次玩的日期、第几天留存（0,1,2...7)、玩法留存用户数\n\n各玩法首周上线日期：\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename,dws_jordass_mode_roundrecord_di.mapname]\nA: Let’s think step by step. The SQL query for the question \"统计各个玩法上线首周留存情况...\" needs these tables = [dws_jordass_mode_roundrecord_di], so we only reference a single base table but will use multiple derived subqueries and unions to separate modes.\nPlus, it requires nested/derived queries and UNION ALL across mode-specific selections to build per-mode first-play dates and per-mode daily activity windows, and then a join between those derived results to compute day-diff retention; the sub-questions needed = [\"对于每个玩法和每个玩家，在该玩法上线首周内的首次玩的日期是什么？\",\"对于每个玩法，在首周后第0~7天哪些玩家有行为？\"].\nSo, we need derived subqueries (UNION ALL) and a LEFT JOIN between derived sets, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql30": "Q: \"统计2019.5.8至2025.3.30 分月的玩法主玩情况\n输出：月份(201905、201906、...、202503)、主玩玩法、主玩人数、总参与人数\"\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.roundtime,dwd_jordass_playerexitgamerecord_hi.tdbank_imp_date,dwd_jordass_playerexitgamerecord_hi.mode]\nA: Let’s think step by step. The SQL query for the question \"统计2019.5.8至2025.3.30 分月的玩法主玩情况...\" needs these tables = [dws_jordass_mode_roundrecord_di, dwd_jordass_playerexitgamerecord_hi], so we need to combine data from two tables (UNION ALL) and aggregate per player-month-mode.\nPlus, it requires intermediate aggregation per (mons, vplayerid, mode) to compute total roundtime/roundcnt and then windowing (row_number) to pick each player's main mode per month; the sub-question needed = [\"对于每个玩家每个月，计算其在每个玩法的累计时长与对局数以确定主玩玩法。\"].\nSo, we need CTE/aggregation + row_number windowing and UNION of sources, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql33": "Q: \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数（去重）有多少，其中多少人是12月13日及以前有参与过建筑争夺的老玩家，有多少是新玩家\n输出: 玩家人数、老玩家人数、新玩家人数\"\nschema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_playermatchrecord_stat_df.dtstatdate,dws_jordass_playermatchrecord_stat_df.vplayerid]\nA: Let’s think step by step. The SQL query for the question \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数...\" needs these tables = [dws_jordass_matchlog_stat_di, dws_jordass_playermatchrecord_stat_df], so we need JOIN between the set of players in the target window and the set of players who played earlier.\nPlus, it requires a subquery to identify the target-window distinct players and a subquery to identify prior players (on 20241213 or earlier), then a LEFT JOIN to count existing vs new; the sub-question needed = [\"在2024-12-14到2024-12-20期间，哪些玩家参与了建筑争夺？\",\"在2024-12-13及以前，哪些玩家曾参与建筑争夺？\"].\nSo, we need subqueries and LEFT JOIN/EXCEPT-style logic, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql34": "Q: \"统计2024.9.17-2024.9.23 和 2024.10.8-2024.10.14    每天点击按钮后加入玩法，再之后点击确认的人数，以及这些人加入玩法的次数                                                       输出：日期(20240917、...、20240923、20241008、...、20241014)，人数，人次\"\nschema_links: [dws_jordass_buttonpress_pre_di.dtstatdate,dws_jordass_buttonpress_pre_di.vplayerid,dws_jordass_buttonpress_pre_di.dteventtime,dws_jordass_buttonpress_pre_di.buttontype]\nA: Let’s think step by step. The SQL query for the question \"统计2024.9.17-2024.9.23 和 2024.10.8-2024.10.14 …\" 只涉及 1 张表 = [dws_jordass_buttonpress_pre_di]，但需要 3 类事件\ntype = 411111(点击按钮) 411120(加入玩法) 411123(确认)。且要做事件顺序约束，必须拆三段，再过滤区间，编号 join。\nPlus 会需要 row_number() 为 411120 编 rank。所以用 nested 派生集。\nSo，我们需要的 sub-questions = [\"这些日期内各玩家的 411111 事件是什么？\",\"这些日期内各玩家的 411120 事件，并给加入事件排序 rank？\",\"玩家在 411120 之后有 411123 吗？\"]\nLabel: \"NESTED\"",
  "sql35": "Q: \"统计2024年3月26日~4月3日、2024年5月28日~6月5日，不同对局类型的游戏和玩法留存情况\n输出：统计日期(20240326、...、20240403、20240528、...、20240605)、对局类型（第一人称、单排、双排、四排），每日对局人数、次数、对局总时长(秒)、游戏次留人数、游戏7留人数，玩法次留人数、玩法7留人数\"\nschema_links:[dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.mode,dws_jordass_mode_roundrecord_di.roundcnt,dws_jordass_mode_roundrecord_di.roundtime,dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid]\nA: Let’s think step by step. The SQL query for the question \"统计2024-03-26~04-03 与 2024-05-28~06-05 的不同对局类型留存\" 需要两层 derived。\nbase事实：对局在 dws_jordass_mode_roundrecord_di，登录在 dws_jordass_login_di。\n我们必须要先把对局做成一个“round_user”派生表（聚合用户-日期-对局模式的对局次数与时长），然后基于 round_user 绑第二天/第7天，再用登录表做“游戏次留/7留”，用 round_user 做“玩法次留/7留”。\n所以 sub-questions needed = [\"每天每对局类型 每玩家 对局次数/时长是多少？\",\"对局日+1 天是否该玩家在游戏登录？\",\"对局日+1 天是否该玩家在该玩法仍有对局？\",\"对局日+6 天 同理\"]。\n所以 SQL类型 = NESTED。\nLabel:\"NESTED\"",
  "sql37": "Q: \"统计注册日期在2025.4.1-2025.5.30的模拟器新进用户在用户类型（模拟器、手机端、整体砺刃游戏内），次留、三留、七留、14留、30留情况\n输出:日期(20250401、...、20250530)、人数、用户类型（模拟器、手机端、游戏内、未知）、次留人数、三留人数、七留人数、14留人数、30留人数\"\nschema_links: [dws_jordass_emulator_df.dregdate,dws_jordass_emulator_df.vplayerid,dws_jordass_emulator_df.dtstatdate,dws_jordass_emulator_df.platid,dws_jordass_device_login_di.dtstatdate,dws_jordass_device_login_di.vplayerid,dws_jordass_device_login_di.device_type,dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid,dws_jordass_login_di.platid]\nA: Let’s think step by step. 该问题只需要引用三个表 = [dws_jordass_emulator_df, dws_jordass_device_login_di, dws_jordass_login_di]。\n需求分析：\n- 需要先构建 cohort（模拟器新进用户），即从 dws_jordass_emulator_df 拉取在统计基准日（限制为 dtstatdate='20251001'）下，注册日期 dregdate 在 20250401~20250530 的用户列表（s1）。\n- 需要构建行为表（s2），包含三类行为来源并做 UNION ALL：手机端登录（device_type=0）、模拟器登录（device_type in (1,5)）从 dws_jordass_device_login_di，以及整体游戏内登录从 dws_jordass_login_di（不区分 platid），三者都提供 dtstatdate, vplayerid, user_type 标签。\n- s2 的时间范围需要覆盖 cohort 日期区间后至少 30 天（即 dtstatdate 从 20250401 到 date_add('20250530',29)），以便计算 1/3/7/14/30 留存。\n- 将 cohort s1 与行为 s2 按 vplayerid 关联，然后按 cohort 日期（s1.ds）和 user_type 聚合，使用 conditional distinct counts（case when s2.ds = date_add(s1.ds, N) then s1.vplayerid end）来统计各天留存人数。\n所以 sub-questions needed = [\"如何从 emulator 表里取出符合注册日期与统计基准日的 cohort？\",\"如何把手机端/模拟器/游戏内三类行为合并成统一的行为表并包含日期范围？\",\"如何按 cohort 日期和用户类型统计次留/三留/七留/14留/30留？\"]\n所以，需要两个派生表（s1: cohort，s2: 行为 union），并用 LEFT JOIN + 聚合统计。该 SQL 可归类为 \"NESTED\"。\nLabel: \"NESTED\"",
  "sql38": "Q: \"统计不同玩法不同用户类型的参与情况\n\n输出：玩法、用户类型（砺刃新增、砺刃回流（流失60天以上）、砺刃回流（流失21-59天）、砺刃回流（流失14-20天）、砺刃回流（流失7-13天）、砺刃留存、平台盘内、平台盘外）、上线后3天参与用户数、上线后3天总用户数\n\n各玩法上线日期：\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nschema_links: [dws_jordass_login_df.dtstatdate,dws_jordass_login_df.dregdate,dws_jordass_login_df.vplayerid,dws_jordass_login_df.cbitmap,dws_mgamejp_login_user_activity_di.dtstatdate,dws_mgamejp_login_user_activity_di.suserid,dws_mgamejp_login_user_activity_di.sgamecode,dws_mgamejp_login_user_activity_di.saccounttype,dws_mgamejp_login_user_activity_di.splattype,dws_mgamejp_login_user_activity_di.splat,dim_jordass_playerid2suserid_nf.vplayerid,dim_jordass_playerid2suserid_nf.suserid,dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename]\nA: Let’s think step by step. 该问题涉及多个数据源，需要对用户进行多维分类并统计上线后3天的参与情况，主要流程为：\n\n1) 数据源：需要引用表 = [dws_jordass_login_df, dws_mgamejp_login_user_activity_di, dim_jordass_playerid2suserid_nf, dws_jordass_mode_roundrecord_di]。\n2) 核心思路：\n   - 从 dws_jordass_login_df 在每个玩法上线后第3天（示例里用 date_add(上线日,2)）抽取用户基础信息（包括 dregdate、cbitmap 等），作为判断“砺刃新增/留存/回流”所需字段（CTE usertype）。\n   - 从平台大盘表 dws_mgamejp_login_user_activity_di 抽取上线前一周的平台活跃情况，判定是否属于“平台盘内/盘外”（CTE dapan）；并通过 dim_jordass_playerid2suserid_nf 将平台用户 id（suserid）映射为游戏 vplayerid（CTE dapan2jordass）。\n   - 从玩法行为表 dws_jordass_mode_roundrecord_di 抽取上线后3天参与玩法的玩家（CTE playuser），用于最终分组统计。\n   - 基于 usertype（包含 cbitmap 和 dregdate）对 playuser 中每位玩家分类（砺刃新增/留存/不同区间回流），并结合 dapan2jordass 判定平台盘内/盘外。\n   - 最终按玩法+用户类型统计上线后3天参与用户数与对应总数（通过 join/union 聚合得到两个数）。\n\n3)所以 sub-questions needed = [\"如何在上线后第3天抽取每玩法用户的注册/活跃标识（cbitmap）？\",\"如何从平台大盘判定上线前一周是否在平台活跃并映射到游戏 vplayerid？\",\"如何从玩法记录里抽取上线后3天内参与玩法的玩家？\",\"如何基于 cbitmap 与 dregdate 定义新增/留存/回流分组？\",\"如何把上述结果聚合成最终输出（玩法、用户类型、上线后3天参与数、上线后3天总数）？\"].\n\n因此，需要使用多个 CTE（派生表）和 UNION/JOIN 操作，SQL 可归为 \"NESTED\"。\nLabel: \"NESTED\"",
  "sql39": "Q: \"\n统计各个玩法参与用户其他玩法流入和双栖情况\n\n输出：流入玩法、流出玩法、上线后3天流入玩法参与用户数、上线后3天流出用户数、上线后3天双栖用户数、上线前一周流出玩法总参与用户数、流出占比、上线后3天流出玩法总参与用户数、双栖占比\n\",\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename,dws_jordass_mode_roundrecord_di.mapname,dws_jordass_mode_roundrecord_di.submode]\nA: Let’s think step by step. 该问题需要从单表 dws_jordass_mode_roundrecord_di 构造多个派生集（CTE/子查询）：\n1) 先抽取每个“流入玩法”上线当日及其上线后3天（上线日 + 2）内参与该玩法的玩家集合（playuser）。\n2) 针对每个流入玩法，构造一个覆盖【上线前7天到上线后3天】的玩家-玩法映射（按规则映射为流出玩法分类 playclass1），并标记玩家是否在上线前一周（islast）和上线后3天窗口内（isthis）有该流出玩法行为（allplayuser）。\n3) 用 playuser 与 allplayuser 的关联，统计流入玩法玩家在不同流出玩法上的“流出用户数（上线前玩、上线后没玩但玩了流入玩法）”与“双栖用户数（上线前后都玩了流出玩法）”。\n4) 还需计算各流出玩法在上线前一周的总参与人数以及上线后3天在该流出玩法的总参与人数，用于计算流出占比与双栖占比。\n因此需要的子问题 = [\"如何抽取每个流入玩法上线日及上线后3天的玩家？\",\"如何把所有玩法按规则映射为流出玩法分类并在时间窗口内打标(islast/isthis)？\",\"如何基于两张派生表计算流入/流出/双栖用户数并计算占比？\"].\nSQL 操作手法：使用 CTE（WITH playuser, allplayuser）、大量 UNION ALL（按流入玩法逐个取数并打上 itype 标签）、CASE WHEN 映射流出玩法类别、聚合去重(count(distinct ...))、LEFT JOIN 汇总指标。\n所以该 query 的 SQL 类型可归类为：\"NESTED/CTE + UNION ALL + AGGREGATION\"。\nLabel: \"NESTED\""
}