{
  "sql28": "Q: \"统计各个玩法上线首周留存情况\n输出：玩法、上线首周首次玩的日期、第几天留存（0,1,2...7)、玩法留存用户数\n\n各玩法首周上线日期：\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename,dws_jordass_mode_roundrecord_di.mapname]\nA: Let’s think step by step. The SQL query for the question \"统计各个玩法上线首周留存情况...\" needs these tables = [dws_jordass_mode_roundrecord_di], so we only reference a single base table but will use multiple derived subqueries and unions to separate modes.\nPlus, it requires nested/derived queries and UNION ALL across mode-specific selections to build per-mode first-play dates and per-mode daily activity windows, and then a join between those derived results to compute day-diff retention; the sub-questions needed = [\"对于每个玩法和每个玩家，在该玩法上线首周内的首次玩的日期是什么？\",\"对于每个玩法，在首周后第0~7天哪些玩家有行为？\"].\nSo, we need derived subqueries (UNION ALL) and a LEFT JOIN between derived sets, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql30": "Q: \"统计2019.5.8至2025.3.30 分月的玩法主玩情况\n输出：月份(201905、201906、...、202503)、主玩玩法、主玩人数、总参与人数\"\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.roundtime,dwd_jordass_playerexitgamerecord_hi.tdbank_imp_date,dwd_jordass_playerexitgamerecord_hi.mode]\nA: Let’s think step by step. The SQL query for the question \"统计2019.5.8至2025.3.30 分月的玩法主玩情况...\" needs these tables = [dws_jordass_mode_roundrecord_di, dwd_jordass_playerexitgamerecord_hi], so we need to combine data from two tables (UNION ALL) and aggregate per player-month-mode.\nPlus, it requires intermediate aggregation per (mons, vplayerid, mode) to compute total roundtime/roundcnt and then windowing (row_number) to pick each player's main mode per month; the sub-questions needed = [\"对于每个玩家每个月，计算其在每个玩法的累计时长与对局数以确定主玩玩法。\"].\nSo, we need CTE/aggregation + row_number windowing and UNION of sources, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql33": "Q: \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数（去重）有多少，其中多少人是12月13日及以前有参与过建筑争夺的老玩家，有多少是新玩家\n输出: 玩家人数、老玩家人数、新玩家人数\"\nschema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_playermatchrecord_stat_df.dtstatdate,dws_jordass_playermatchrecord_stat_df.vplayerid]\nA: Let’s think step by step. The SQL query for the question \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数...\" needs these tables = [dws_jordass_matchlog_stat_di, dws_jordass_playermatchrecord_stat_df], so we need JOIN between the set of players in the target window and the set of players who played earlier.\nPlus, it requires a subquery to identify the target-window distinct players and a subquery to identify prior players (on 20241213 or earlier), then a LEFT JOIN to count existing vs new; the sub-questions needed = [\"在2024-12-14到2024-12-20期间，哪些玩家参与了建筑争夺？\",\"在2024-12-13及以前，哪些玩家曾参与建筑争夺？\"].\nSo, we need subqueries and LEFT JOIN/EXCEPT-style logic, then the SQL query can be classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql34": "Q: \"统计2024.9.17-2024.9.23 和 2024.10.8-2024.10.14    每天点击按钮后加入玩法，再之后点击确认的人数，以及这些人加入玩法的次数                                                       输出：日期(20240917、...、20240923、20241008、...、20241014)，人数，人次\"\nschema_links: [dws_jordass_buttonpress_pre_di.dtstatdate,dws_jordass_buttonpress_pre_di.vplayerid,dws_jordass_buttonpress_pre_di.dteventtime,dws_jordass_buttonpress_pre_di.buttontype]\nA: Let’s think step by step. The SQL query for the question \"统计2024.9.17-2024.9.23 和 2024.10.8-2024.10.14 …\" 只涉及 1 张表 = [dws_jordass_buttonpress_pre_di]，但需要 3 类事件\ntype = 411111(点击按钮) 411120(加入玩法) 411123(确认)。且要做事件顺序约束，必须拆三段，再过滤区间，编号 join。\nPlus 会需要 row_number() 为 411120 编 rank。所以用 nested 派生集。\nSo，我们需要的 sub-questions needed = [\"这些日期内各玩家的 411111 事件是什么？\",\"这些日期内各玩家的 411120 事件，并给加入事件排序 rank？\",\"玩家在 411120 之后有 411123 吗？\"]\nLabel: \"NESTED\"",
  "sql35": "Q: \"统计2024年3月26日~4月3日、2024年5月28日~6月5日，不同对局类型的游戏和玩法留存情况\n输出：统计日期(20240326、...、20240403、20240528、...、20240605)、对局类型（第一人称、单排、双排、四排），每日对局人数、次数、对局总时长(秒)、游戏次留人数、游戏7留人数，玩法次留人数、玩法7留人数\"\nschema_links:[dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.mode,dws_jordass_mode_roundrecord_di.roundcnt,dws_jordass_mode_roundrecord_di.roundtime,dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid]\nA: Let’s think step by step. The SQL query for the question \"统计2024-03-26~04-03 与 2024-05-28~06-05 的不同对局类型留存\" 需要两层 derived。\nbase事实：对局在 dws_jordass_mode_roundrecord_di，登录在 dws_jordass_login_di。\n我们必须要先把对局做成一个“round_user”派生表（聚合用户-日期-对局模式的对局次数与时长），然后基于 round_user 绑第二天/第7天，再用登录表做“游戏次留/7留”，用 round_user 做“玩法次留/7留”。\n所以 sub-questions needed = [\"每天每对局类型 每玩家 对局次数/时长是多少？\",\"对局日+1 天是否该玩家在游戏登录？\",\"对局日+1 天是否该玩家在该玩法仍有对局？\",\"对局日+6 天 同理\"]。\n所以 SQL类型 = NESTED。\nLabel:\"NESTED\"",
  "sql37": "Q: \"统计注册日期在2025.4.1-2025.5.30的模拟器新进用户在用户类型（模拟器、手机端、整体砺刃游戏内），次留、三留、七留、14留、30留情况\n输出:日期(20250401、...、20250530)、人数、用户类型（模拟器、手机端、游戏内、未知）、次留人数、三留人数、七留人数、14留人数、30留人数\"\nschema_links: [dws_jordass_emulator_df.dregdate,dws_jordass_emulator_df.vplayerid,dws_jordass_emulator_df.dtstatdate,dws_jordass_emulator_df.platid,dws_jordass_device_login_di.dtstatdate,dws_jordass_device_login_di.vplayerid,dws_jordass_device_login_di.device_type,dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid,dws_jordass_login_di.platid]\nA: Let’s think step by step. 该问题只需要引用三个表 = [dws_jordass_emulator_df, dws_jordass_device_login_di, dws_jordass_login_di]。\n需求分析：\n- 需要先构建 cohort（模拟器新进用户），即从 dws_jordass_emulator_df 拉取在统计基准日（限制为 dtstatdate='20251001'）下，注册日期 dregdate 在 20250401~20250530 的用户列表（s1）。\n- 需要构建行为表（s2），包含三类行为来源并做 UNION ALL：手机端登录（device_type=0）、模拟器登录（device_type in (1,5)）从 dws_jordass_device_login_di，以及整体游戏内登录从 dws_jordass_login_di（不区分 platid），三者都提供 dtstatdate, vplayerid, user_type 标签。\n- s2 的时间范围需要覆盖 cohort 日期区间后至少 30 天（即 dtstatdate 从 20250401 到 date_add('20250530',29)），以便计算 1/3/7/14/30 留存。\n- 将 cohort s1 与行为 s2 按 vplayerid 关联，然后按 cohort 日期（s1.ds）和 user_type 聚合，使用 conditional distinct counts（case when s2.ds = date_add(s1.ds, N) then s1.vplayerid end）来统计各天留存人数。\n所以 sub-questions needed = [\"如何从 emulator 表里取出符合注册日期与统计基准日的 cohort？\",\"如何把手机端/模拟器/游戏内三类行为合并成统一的行为表并包含日期范围？\",\"如何按 cohort 日期和用户类型统计次留/三留/七留/14留/30留？\"]\n所以，需要两个派生表（s1: cohort，s2: 行为 union），并用 LEFT JOIN + 聚合统计。该 SQL 可归类为 \"NESTED\"。\nLabel: \"NESTED\"",
  "sql38": "Q: \"统计不同玩法不同用户类型的参与情况\n\n输出：玩法、用户类型（砺刃新增、砺刃回流（流失60天以上）、砺刃回流（流失21-59天）、砺刃回流（流失14-20天）、砺刃回流（流失7-13天）、砺刃留存、平台盘内、平台盘外）、上线后3天参与用户数、上线后3天总用户数\n\n各玩法上线日期：\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nschema_links: [dws_jordass_login_df.dtstatdate,dws_jordass_login_df.dregdate,dws_jordass_login_df.vplayerid,dws_jordass_login_df.cbitmap,dws_mgamejp_login_user_activity_di.dtstatdate,dws_mgamejp_login_user_activity_di.suserid,dws_mgamejp_login_user_activity_di.sgamecode,dws_mgamejp_login_user_activity_di.saccounttype,dws_mgamejp_login_user_activity_di.splattype,dws_mgamejp_login_user_activity_di.splat,dim_jordass_playerid2suserid_nf.vplayerid,dim_jordass_playerid2suserid_nf.suserid,dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename]\nA: Let’s think step by step. 该问题涉及多个数据源，需要对用户进行多维分类并统计上线后3天的参与情况，主要流程为：\n\n1) 数据源：需要引用表 = [dws_jordass_login_df, dws_mgamejp_login_user_activity_di, dim_jordass_playerid2suserid_nf, dws_jordass_mode_roundrecord_di]。\n2) 核心思路：\n   - 从 dws_jordass_login_df 在每个玩法上线后第3天（示例里用 date_add(上线日,2)）抽取用户基础信息（包括 dregdate、cbitmap 等），作为判断“砺刃新增/留存/回流”所需字段（CTE usertype）。\n   - 从平台大盘表 dws_mgamejp_login_user_activity_di 抽取上线前一周的平台活跃情况，判定是否属于“平台盘内/盘外”（CTE dapan）；并通过 dim_jordass_playerid2suserid_nf 将平台用户 id（suserid）映射为游戏 vplayerid（CTE dapan2jordass）。\n   - 从玩法行为表 dws_jordass_mode_roundrecord_di 抽取上线后3天参与玩法的玩家（CTE playuser），用于最终分组统计。\n   - 基于 usertype（包含 cbitmap 和 dregdate）对 playuser 中每位玩家分类（砺刃新增/留存/不同区间回流），并结合 dapan2jordass 判定平台盘内/盘外。\n   - 最终按玩法+用户类型统计上线后3天参与用户数与对应总数（通过 join/union 聚合得到两个数）。\n\n3)所以 sub-questions needed = [\"如何在上线后第3天抽取每玩法用户的注册/活跃标识（cbitmap）？\",\"如何从平台大盘判定上线前一周是否在平台活跃并映射到游戏 vplayerid？\",\"如何从玩法记录里抽取上线后3天内参与玩法的玩家？\",\"如何基于 cbitmap 与 dregdate 定义新增/留存/回流分组？\",\"如何把上述结果聚合成最终输出（玩法、用户类型、上线后3天参与数、上线后3天总数）？\"].\n\n因此，需要使用多个 CTE（派生表）和 UNION/JOIN 操作，SQL 可归为 \"NESTED\"。\nLabel: \"NESTED\"",
  "sql39": "Q: \"\n统计各个玩法参与用户其他玩法流入和双栖情况\n\n输出：流入玩法、流出玩法、上线后3天流入玩法参与用户数、上线后3天流出用户数、上线后3天双栖用户数、上线前一周流出玩法总参与用户数、流出占比、上线后3天流出玩法总参与用户数、双栖占比\n\",\nschema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename,dws_jordass_mode_roundrecord_di.mapname,dws_jordass_mode_roundrecord_di.submode]\nA: Let’s think step by step. 该问题需要从单表 dws_jordass_mode_roundrecord_di 构造多个派生集（CTE/子查询）：\n1) 先抽取每个“流入玩法”上线当日及其上线后3天（上线日 + 2）内参与该玩法的玩家集合（playuser）。\n2) 针对每个流入玩法，构造一个覆盖【上线前7天到上线后3天】的玩家-玩法映射（按规则映射为流出玩法分类 playclass1），并标记玩家是否在上线前一周（islast）和上线后3天窗口内（isthis）有该流出玩法行为（allplayuser）。\n3) 用 playuser 与 allplayuser 的关联，统计流入玩法玩家在不同流出玩法上的“流出用户数（上线前玩、上线后没玩但玩了流入玩法）”与“双栖用户数（上线前后都玩了流出玩法）”。\n4) 还需计算各流出玩法在上线前一周的总参与人数以及上线后3天在该流出玩法的总参与人数，用于计算流出占比与双栖占比。\n所以 sub-questions needed = [\"如何抽取每个流入玩法上线日及上线后3天的玩家？\",\"如何把所有玩法按规则映射为流出玩法分类并在时间窗口内打标(islast/isthis)？\",\"如何基于两张派生表计算流入/流出/双栖用户数并计算占比？\"].\nSQL 操作手法：使用 CTE（WITH playuser, allplayuser）、大量 UNION ALL（按流入玩法逐个取数并打上 itype 标签）、CASE WHEN 映射流出玩法类别、聚合去重(count(distinct ...))、LEFT JOIN 汇总指标。\n所以该 query 的 SQL 类型可归类为：\"NESTED/CTE + UNION ALL + AGGREGATION\"。\nLabel: \"NESTED\"",
  "sql45": "Q: \"统计2024.01.01-2024.01.07参与乐园子玩法拼图狂欢在202401.08-2024.01.14没玩乐园子玩法拼图狂欢在2024.01.15-2024.01.21又玩了乐园子玩法拼图狂欢的用户\n输出：玩家数\"\nschema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_matchlog_stat_di.imode]\nA: Let’s think step by step. 该问题只需要表 = [dws_jordass_matchlog_stat_di]，并通过三个时间窗口分别筛出在首周有行为、次周无行为、第三周有行为的玩家集合，然后对集合做集合运算（左连接 + 过滤 null + 内连接）来得到最终玩家数。\n所以 sub-questions needed = [\"在2024-01-01到2024-01-07期间，有哪些玩家玩了 imode=1287652322611036928？\",\"在2024-01-08到2024-01-14期间，有哪些玩家玩了该 imode？\",\"在2024-01-15到2024-01-21期间，有哪些玩家玩了该 imode？\"]。\n实现方法：使用三个派生表（a、b、c）分别选出三个时间窗口的 distinct vplayerid，然后 a LEFT JOIN b（并筛 b.vplayerid is null），再 JOIN c。SQL 结构为简单的派生表 + 连接，分类为 \"NESTED\"。\nLabel: \"NESTED\"",
  "sql46": "Q: \"统计2024.1.1-2024.2.2期间，每个自然周不同周活跃天数玩家数\n输出：统计周(1、2、3...、5)、周活跃天数、玩家数\"\nschema_links: [dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid,dws_jordass_login_di.platid]\nA: Let's think step by step. 本问题使用的表 = [dws_jordass_login_di]，所以 sub-questions needed = [\"对于每个玩家，在每个自然周内活跃了多少不同的天（即周内去重的 dtstatdate 天数）？\",\"对于每个统计周（weekofyear），统计每个“周活跃天数”对应的玩家数（去重玩家）。\"]。\n实现思路：先对基础表按玩家 & weekofyear 聚合得到每个玩家在该周的活跃天数（子查询/派生表），然后再对该派生表按 week 与 active_days 聚合计数玩家数。\n因此需要一个派生表（f：vplayerid, week, active_days），外层再 group by week, active_days。\nSQL 类型可归为：\"NESTED\"。\nLabel: \"NESTED\"",
  "sql48": "Q: \"统计2023.12.1流失7天的回流用户数和流失30天的回流用户数\n输出：流失7天的回流用户数，流失30天的回流用户数\"\nschema_links: [dws_jordass_login_df.vplayerid,dws_jordass_login_df.dregdate,dws_jordass_login_df.dtstatdate,dws_jordass_login_df.cbitmap]\nA: Let’s think step by step. The SQL query for the question \"统计2023.12.1流失7天的回流用户数和流失30天的回流用户数\" only needs table = [dws_jordass_login_df]. It requires checking per user behavior bitmap (cbitmap) to judge 7-day lost return and 30-day lost return — 所以 sub-questions needed = [\"如何判断一个玩家是否为流失7天回流？\",\"如何判断一个玩家是否为流失30天回流？\"]. It uses one derived subquery to flag users, then outer aggregate to count 2 metrics. So query type = simple derived with inline boolean logic.\nLabel: \"NESTED\"",
  "sql49": "Q: \"2024年10月1-2024年10月7 用周期开始时间判断玩法上线时间在7天及以上，周期结束时间判断玩法上线时间在90天及以内的玩法，统计周期内这些玩法的参与和留存情况\n输出：周期(20241001-20241007)，日期(20241001、...、20241007)，参与人数，次留人数\"\nschema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_matchlog_stat_di.imode,dim_jordass_submodeonline_nf.matchsubmodegroup,dim_jordass_submodeonline_nf.onlinedate]\nA: Let’s think step by step. 这个问题只涉及两张表 dws_jordass_matchlog_stat_di 与 dim_jordass_submodeonline_nf，需要根据 submode 表中的上线时间做 datediff 判断筛选符合上线时间窗口的玩法，再在 matchlog 的周期天内取 distinct 玩家，最后做 t+1 次留，因此需要一个 derived CTE 先算周期内符合玩法条件的日粒度player，再 self left join 得出次日留存。\n所以 sub-questions needed = [\"哪些玩法满足上线距20241001 ≥7 且上线距20241007 ≤90？\",\"这些玩法在10-1~10-8 每天有哪些玩家参与？\",\"对于每个日期玩家是否 T+1 出现？\"].\n所以最终 SQL 类型 = \"NESTED\"。\nLabel: \"NESTED\"",
  "sql56": "Q: \"时间：2024.01.01-2024.01.31\n每日新增用户的LTV，LTV1~LTV10\n输出：注册日期(20240101、20240102、...、20240131)、新进用户数、LTV1、LTV3、LTV7、LTV14、LTV30、LTV60、LTV90、LTV180\"\nschema_links: [dws_jordass_login_df.dregdate,dws_jordass_login_df.dtstatdate,dws_jordass_login_df.vplayerid,dws_jordass_water_di.dtstatdate,dws_jordass_water_di.vplayerid,dws_jordass_water_di.imoney]\nA: Let’s think step by step. The SQL query for the question \"每日新增用户LTV…\" 只需要 2 张表：dws_jordass_login_df（拿注册日、注册用户） + dws_jordass_water_di（拿充值）。\n问题本质是：先取 2024/01/01-2024/01/31 的新增玩家，再 left join 全部后续 180天的付费，算 datediff 然后做 LTVN＝ sum(pay< N天)/新增人数。\n因此 sub-questions needed = [\"取20240101-20240131新增用户列表 (注册日+uid)\",\"关联付费取每玩家每日付费并算 datediff\"]\n最终是 典型 NESTED（先子表 s1，再 join s2，再外层 group）\nLabel: \"NESTED\"",
  "sql57": "Q: \"统计限定抽取阶梯活动每天的pv和角色数\n活动日期\t2024.11.29-12.19\t\n输出：日期(20241129、...、20241219、汇总)、pv、uv\"\nschema_links: [dwd_jordass_activitypress_hi.tdbank_imp_date,dwd_jordass_activitypress_hi.uid,dwd_jordass_activitypress_hi.ireason,dwd_jordass_activitypress_hi.buttontype,dwd_jordass_activitypress_hi.extarg1]\nA: Let’s think step by step. The SQL query for the question \"统计限定抽取阶梯活动每天的pv和角色数\" needs only table = [dwd_jordass_activitypress_hi].\nPlus, it requires 2 logical chunks: one daily aggregation and one total aggregation, and we UNION ALL them.\nsub-questions needed = [\"限定抽取阶梯活动每日 pv / uv 是多少？\", \"整个周期总的 pv / uv 是多少？\"].\nSo, this query uses UNION ALL combining per-day and total. It is classified as \"NESTED\".\nLabel: \"NESTED\"",
  "sql59": "Q: \"统计：20250111-20250124时间区间内，幻境使者活动抽奖用户第X次触发赠送后，这些用户的总抽奖次数\n输出：第X次触发,触发用户数,用户总抽奖次数\"\nschema_links: [dwd_jordass_activityrecord_hi.vplayerid,dwd_jordass_activityrecord_hi.tdbank_imp_date,dwd_jordass_activityrecord_hi.dteventtime,dwd_jordass_activityrecord_hi.actid,dwd_jordass_activityrecord_hi.acttype,dwd_jordass_activityrecord_hi.recodtype,dwd_jordass_activityrecord_hi.strarg1,dwd_jordass_activityrecord_hi.arg1]\nA: Let’s think step by step. The SQL query for the question \"统计：20250111-20250124...第X次触发赠送后用户总抽奖次数\" only needs table dwd_jordass_activityrecord_hi, but requires at least two derived sets: one for per-user per-trigger boundary frames (row_number & next event time) and one for draw count per event time, then join by time window. sub-questions needed = [\"哪些记录是触发赠送\",\"每个用户这些触发按时间排序后的第X次触发的窗口\",\"在该窗口内累计 arg1\"]\nSo we need window functions + derived subqueries + join — classification = \"NESTED\".\nLabel: \"NESTED\""





}