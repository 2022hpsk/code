{
  "sql28": "Q: \"统计各个玩法上线首周留存情况\n输出:玩法、上线首周首次玩的日期、第几天留存(0,1,2...7)、玩法留存用户数\n\n各玩法首周上线日期:\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nSchema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename]\nA: Let's think step by step. \"统计各个玩法上线首周留存情况...\" can be solved by knowing the answer to the following sub-questions \"对于每个玩法与每个玩家，首周内该玩家的首次玩的日期是什么？\" 和 \"在首周后的第0~7天中，该玩法哪些玩家有行为？\".\nThe SQL query for the sub-question \"对于每个玩法与每个玩家，首周内该玩家的首次玩的日期是什么？\" is:\n\nselect\n    itype,\n    min(dtstatdate) as dtstatdate,\n    vplayerid\nfrom (\n    select '广域战场'      as itype, min(dtstatdate) as dtstatdate, vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240723' and dtstatdate <= date_add('20240723',6)\n      and submodename = '广域战场模式'\n    group by vplayerid\n\n    union all\n    select '消灭战', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20230804' and dtstatdate <= date_add('20230804',6)\n      and modename='组队竞技' and submodename like '%消灭战模式%'\n    group by vplayerid\n\n    union all\n    select '幻想混战', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20241115' and dtstatdate <= date_add('20241115',6)\n      and modename='创意创作间' and submodename='幻想混战'\n    group by vplayerid\n\n    union all\n    select '荒野传说', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240903' and dtstatdate <= date_add('20240903',6)\n      and modename='休闲模式' and submodename in ('荒野传说','荒野沙漠')\n    group by vplayerid\n\n    union all\n    select '策略载具', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20241010' and dtstatdate <= date_add('20241010',6)\n      and modename='休闲模式' and submodename like '%策略载具%'\n    group by vplayerid\n\n    union all\n    select '炎夏混战', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240625' and dtstatdate <= date_add('20240625',6)\n      and modename='创意创作间' and submodename like '%炎夏混战%'\n    group by vplayerid\n\n    union all\n    select '单人装备', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240517' and dtstatdate <= date_add('20240517',6)\n      and modename='组队竞技' and submodename like '%单人装备%'\n    group by vplayerid\n\n    union all\n    select '交叉堡垒', min(dtstatdate), vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240412' and dtstatdate <= date_add('20240412',6)\n      and modename='组队竞技' and submodename like '%交叉堡垒%'\n    group by vplayerid\n) t\ngroup by itype, vplayerid;\n\n\nSo, the answer to the question \"统计各个玩法上线首周留存情况...\" is =\nIntermediate_representation: 使用两个派生表(a:每玩法每玩家首日；b:每玩法每玩家在首周后第0~13天的行为记录)，然后按玩法、首日和 datediff 关联统计 day 维度留存人数。\nSQL:\n\nselect  a.itype,\n        a.dtstatdate,\n        datediff(b.dtstatdate,a.dtstatdate) as idaynum,\n        count(distinct a.vplayerid)           as iusernum\nfrom (                      \n    select\n        itype,\n        min(dtstatdate) as dtstatdate,\n        vplayerid\n    from  (\n        select '广域战场'      as itype,\n                min(dtstatdate) as dtstatdate,\n                vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240723' and dtstatdate <= date_add('20240723',6)\n        and submodename = '广域战场模式'\n        group by vplayerid\n\n        union all\n        select '消灭战', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20230804' and dtstatdate <= date_add('20230804',6)\n        and modename='组队竞技' and submodename like '%消灭战模式%'\n        group by vplayerid\n\n        union all\n        select '幻想混战', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20241115' and dtstatdate <= date_add('20241115',6)\n        and modename='创意创作间' and submodename='幻想混战'\n        group by vplayerid\n\n        union all\n        select '荒野传说', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240903' and dtstatdate <= date_add('20240903',6)\n        and modename='休闲模式' and submodename in ('荒野传说','荒野沙漠')\n        group by vplayerid\n\n        union all\n        select '策略载具', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20241010' and dtstatdate <= date_add('20241010',6)\n        and modename='休闲模式' and submodename like '%策略载具%'\n        group by vplayerid\n\n        union all\n        select '炎夏混战', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240625' and dtstatdate <= date_add('20240625',6)\n        and modename='创意创作间' and submodename like '%炎夏混战%'\n        group by vplayerid\n\n        union all\n        select '单人装备', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240517' and dtstatdate <= date_add('20240517',6)\n        and modename='组队竞技' and submodename like '%单人装备%'\n        group by vplayerid\n\n        union all\n        select '交叉堡垒', min(dtstatdate), vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240412' and dtstatdate <= date_add('20240412',6)\n        and modename='组队竞技' and submodename like '%交叉堡垒%'\n        group by vplayerid\n    ) t\n    group by itype, vplayerid\n) a\nleft join (\n        select '广域战场' as itype, dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240723' and dtstatdate <= date_add('20240723',13)\n          and submodename = '广域战场模式'\n        group by dtstatdate, vplayerid\n\n        union all\n        select '消灭战', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20230804' and dtstatdate <= date_add('20230804',13)\n          and modename='组队竞技' and submodename like '%消灭战模式%'\n        group by dtstatdate, vplayerid\n\n        union all\n        select '幻想混战', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20241115' and dtstatdate <= date_add('20241115',13)\n          and modename='创意创作间' and submodename='幻想混战'\n        group by dtstatdate, vplayerid\n\n        union all\n        select '荒野传说', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240903' and dtstatdate <= date_add('20240903',13)\n          and modename='休闲模式' and submodename in ('荒野传说','荒野沙漠')\n        group by dtstatdate, vplayerid\n\n        union all\n        select '策略载具', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20241010' and dtstatdate <= date_add('20241010',13)\n          and modename='休闲模式' and submodename like '%策略载具%'\n        group by dtstatdate, vplayerid\n\n        union all\n        select '炎夏混战', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240625' and dtstatdate <= date_add('20240625',13)\n          and modename='创意创作间' and submodename like '%炎夏混战%'\n        group by dtstatdate, vplayerid\n\n        union all\n        select '单人装备', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240517' and dtstatdate <= date_add('20240517',13)\n          and modename='组队竞技' and submodename like '%单人装备%'\n        group by dtstatdate, vplayerid\n\n        union all\n        select '交叉堡垒', dtstatdate, vplayerid\n        from dws_jordass_mode_roundrecord_di\n        where dtstatdate >= '20240412' and dtstatdate <= date_add('20240412',13)\n          and modename='组队竞技' and submodename like '%交叉堡垒%'\n        group by dtstatdate, vplayerid\n) b\n  on  a.itype      = b.itype\nand  a.vplayerid    = b.vplayerid\nwhere datediff(b.dtstatdate,a.dtstatdate) between 0 and 7\ngroup by a.itype, a.dtstatdate, datediff(b.dtstatdate,a.dtstatdate);\n",
  "sql30": "Q: \"统计2019.5.8至2025.3.30 分月的玩法主玩情况\n输出:月份(201905、201906、...、202503)、主玩玩法、主玩人数、总参与人数\"\nSchema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.roundtime,dws_jordass_mode_roundrecord_di.roundcnt,dwd_jordass_playerexitgamerecord_hi.tdbank_imp_date,dwd_jordass_playerexitgamerecord_hi.mode]\nA: Let's think step by step. \"统计2019.5.8至2025.3.30 分月的玩法主玩情况\" can be solved by knowing the answer to the following sub-question \"对于每个玩家在每个月，计算他们在每个玩法的累计时长(或对局数)以确定该玩家的主玩玩法(累计时长最多者)\".\nThe SQL query for the sub-question \"对于每个玩家在每个月，计算他们在每个玩法的累计时长(或对局数)\" is:\n\nwith main_user as (\n    select substr(dtstatdate, 1, 6) mons,\n        case\n            when modename = '传统模式' and submodename like 'CG%' and mapname = '群屿' then '主题群屿'\n            when modename = '传统模式' and mapname = '群屿' then '传统群屿'\n            when modename = '传统模式' and mapname = '假日群岛' then '假日群岛'\n            when modename = '传统模式' and mapname = '荣耀之城' then '荣耀之城'\n            when submodename = '广域战场模式' then '广域战场'\n            when submodename = '极能形态模式' then '极能形态'\n            when modename = '组队竞技' then '组竞'\n            when modename = '乐园' then '乐园'\n            when modename = '领地' then '领地'\n            when modename = '广阔天地' then '广阔天地'\n            else '其他模式'\n        end imodename,\n        vplayerid,\n        sum(roundtime) / 60 roundtime,\n        sum(roundcnt) roundcnt\n   from dws_jordass_mode_roundrecord_di\n   where dtstatdate between '20190508' and '20250330'\n   group by vplayerid, substr(dtstatdate, 1, 6),\n        case\n            when modename = '传统模式' and submodename like 'CG%' and mapname = '群屿' then '主题群屿'\n            when modename = '传统模式' and mapname = '群屿' then '传统群屿'\n            when modename = '传统模式' and mapname = '假日群岛' then '假日群岛'\n            when modename = '传统模式' and mapname = '荣耀之城' then '荣耀之城'\n            when submodename = '广域战场模式' then '广域战场'\n            when submodename = '极能形态模式' then '极能形态'\n            when modename = '组队竞技' then '组竞'\n            when modename = '乐园' then '乐园'\n            when modename = '领地' then '领地'\n            when modename = '广阔天地' then '广阔天地'\n            else '其他模式'\n        end\n\n   union all\n\n   select substr (tdbank_imp_date, 1, 6) mons,\n        '隧道' as modename,\n        vplayerid,\n        sum(roundtime) / 60 roundtime,\n        count(distinct gameid) roundcnt\n   from dwd_jordass_playerexitgamerecord_hi\n   where tdbank_imp_date between '2024061800' and '2025033023'\n     and mode in (3001, 3002, 3003)\n   group by substr (tdbank_imp_date, 1, 6), vplayerid\n)\n\nSo, the answer to the question \"统计2019.5.8至2025.3.30 分月的玩法主玩情况\" is =\nIntermediate_representation: 用 CTE 汇总每月每玩家每玩法的累计时长 / 对局数，按每个月每玩家取 roundtime 最大的玩法为主玩，再统计主玩人数与总参与人数。\nSQL:\n\nwith main_user as (\n    select substr(dtstatdate, 1, 6) mons,\n        case\n            when modename = '传统模式' and submodename like 'CG%' and mapname = '群屿' then '主题群屿'\n            when modename = '传统模式' and mapname = '群屿' then '传统群屿'\n            when modename = '传统模式' and mapname = '假日群岛' then '假日群岛'\n            when modename = '传统模式' and mapname = '荣耀之城' then '荣耀之城'\n            when submodename = '广域战场模式' then '广域战场'\n            when submodename = '极能形态模式' then '极能形态'\n            when modename = '组队竞技' then '组竞'\n            when modename = '乐园' then '乐园'\n            when modename = '领地' then '领地'\n            when modename = '广阔天地' then '广阔天地'\n            else '其他模式'\n        end imodename,\n        vplayerid,\n        sum(roundtime) / 60 roundtime,\n        sum(roundcnt) roundcnt\n   from dws_jordass_mode_roundrecord_di\n   where dtstatdate between '20190508' and '20250330'\n   group by vplayerid, substr(dtstatdate, 1, 6),\n        case\n            when modename = '传统模式' and submodename like 'CG%' and mapname = '群屿' then '主题群屿'\n            when modename = '传统模式' and mapname = '群屿' then '传统群屿'\n            when modename = '传统模式' and mapname = '假日群岛' then '假日群岛'\n            when modename = '传统模式' and mapname = '荣耀之城' then '荣耀之城'\n            when submodename = '广域战场模式' then '广域战场'\n            when submodename = '极能形态模式' then '极能形态'\n            when modename = '组队竞技' then '组竞'\n            when modename = '乐园' then '乐园'\n            when modename = '领地' then '领地'\n            when modename = '广阔天地' then '广阔天地'\n            else '其他模式'\n        end\n\n   union all\n\n   select substr (tdbank_imp_date, 1, 6) mons,\n        '隧道' as modename,\n        vplayerid,\n        sum(roundtime) / 60 roundtime,\n        count(distinct gameid) roundcnt\n   from dwd_jordass_playerexitgamerecord_hi\n   where tdbank_imp_date between '2024061800' and '2025033023'\n     and mode in (3001, 3002, 3003)\n   group by substr (tdbank_imp_date, 1, 6), vplayerid\n)\n\nselect a.mons,\n       a.imodename,\n       a.iusernum,\n       b.iusernumall\nfrom (\n    select mons,\n          imodename,\n          count(vplayerid) iusernum\n    from (\n        select mons, vplayerid, imodename\n        from (\n            select mons,\n                vplayerid,\n                imodename,\n                roundtime,\n                row_number() over (partition by mons, vplayerid order by roundtime desc) as rn\n            from main_user\n        )ff1\n        where rn = 1\n    )f1\n   group by mons, imodename\n) a\nleft join (\n    select mons,\n        imodename,\n        count(vplayerid) iusernumall\n   from main_user\n   group by mons, imodename\n) b \non a.imodename = b.imodename and a.mons = b.mons\norder by a.mons, a.imodename\n;\n",
  "sql33": "Q: \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数(去重)有多少，其中多少人是12月13日及以前有参与过建筑争夺的老玩家，有多少是新玩家\n输出: 玩家人数、老玩家人数、新玩家人数\"\nSchema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_playermatchrecord_stat_df.dtstatdate,dws_jordass_playermatchrecord_stat_df.vplayerid]\nA: Let's think step by step. \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数...\" can be solved by knowing the answer to the following sub-question \"在 2024-12-14 到 2024-12-20 期间，哪些玩家参与了建筑争夺？\" 以及 \"在 2024-12-13(或更早)有哪些玩家曾参与建筑争夺？\"。\nThe SQL query for the sub-question \"在 2024-12-14 到 2024-12-20 期间，哪些玩家参与了建筑争夺？\" is:\n\nselect vplayerid\nfrom dws_jordass_matchlog_stat_di\nwhere dtstatdate between '20241214' and '20241220'\n  and imode = 1344338933661592832\n  and platid = 255\ngroup by vplayerid\n\n\nThe SQL query for the sub-question \"在 2024-12-13(或更早)有哪些玩家曾参与建筑争夺？\" is:\n\nselect vplayerid\nfrom dws_jordass_playermatchrecord_stat_df\nwhere dtstatdate = '20241213'\n  and imode = 1344338933661592832\n  and platid = 255\ngroup by vplayerid\n\n\nSo, the answer to the question \"统计2024年12月14日-2024年12月20日参与建筑争夺玩法的玩家人数...\" is =\nIntermediate_representation: select distinct players in target window left join players in prior-date window and count total / existing / new.\nSQL:\n\nselect\n    count(distinct a.vplayerid) as total_players,\n    count(distinct case when b.vplayerid is not null then a.vplayerid end) as existing_players,\n    count(distinct case when b.vplayerid is null then a.vplayerid end) as new_players\nfrom (\n    select vplayerid\n    from dws_jordass_matchlog_stat_di\n    where dtstatdate between '20241214' and '20241220'\n    and imode = 1344338933661592832\n    and platid = 255\n    group by vplayerid\n) a\nleft join (\n    select vplayerid\n    from dws_jordass_playermatchrecord_stat_df\n    where dtstatdate = '20241213'\n    and imode = 1344338933661592832\n    and platid = 255\n    group by vplayerid\n) b\non a.vplayerid = b.vplayerid\n;\n",
  "sql34": "Q: \"统计2024.9.17-2024.9.23 和 2024.10.8-2024.10.14    每天点击按钮后加入玩法，再之后点击确认的人数，以及这些人加入玩法的次数    输出:日期、人数、人次\"\nSchema_links: [dws_jordass_buttonpress_pre_di.dtstatdate,dws_jordass_buttonpress_pre_di.vplayerid,dws_jordass_buttonpress_pre_di.dteventtime,dws_jordass_buttonpress_pre_di.buttontype]\nA: Let's think step by step. \"…每天点击按钮后加入玩法再之后确认的人数…\" 可以拆为:先要回答 sub 问题 \"在日期区间内的 411111、411120(需 row_number)、411123 各自是什么？\"。\n\n411111 的 SQL:\nselect dtstatdate as ds, vplayerid, dteventtime  from dws_jordass_buttonpress_pre_di where buttontype=411111 and ((dtstatdate between '20240917' and '20240923') or (dtstatdate between '20241008' and '20241014'));\n\n411120 的 SQL:\nselect dtstatdate as ds, vplayerid, dteventtime, row_number() over(partition by vplayerid order by dteventtime) as irank from dws_jordass_buttonpress_pre_di where buttontype=411120 and ((dtstatdate between '20240917' and '20240923') or (dtstatdate between '20241008' and '20241014'));\n\n411123 的 SQL:\nselect dtstatdate as ds, vplayerid, dteventtime  from dws_jordass_buttonpress_pre_di where buttontype=411123 and ((dtstatdate between '20240917' and '20240923') or (dtstatdate between '20241008' and '20241014'));\n\n所以总问题答案 =\nIntermediate_representation: 用三个 derived table (s1:411111, s2:411120 带 row_number, s3:411123) 然后依事件顺序连接统计 distinct user 与 distinct user, irank\nSQL:\n\nselect\n    ds,\n    count(distinct vplayerid) as user_cnt,\n    count(distinct vplayerid, irank) as user_times\nfrom (\n    select\n        s2.ds,\n        s2.vplayerid,\n        s2.irank\n    from (\n        select dtstatdate as ds, vplayerid, dteventtime\n        from dws_jordass_buttonpress_pre_di\n        where buttontype = 411111\n        and  ((dtstatdate between '20240917' and '20240923') or (dtstatdate between '20241008' and '20241014'))\n    ) s1\n    join (\n        select dtstatdate as ds, vplayerid, dteventtime, row_number() over (partition by vplayerid order by dteventtime) as irank\n        from dws_jordass_buttonpress_pre_di\n        where buttontype = 411120\n        and ((dtstatdate between '20240917' and '20240923') or (dtstatdate between '20241008' and '20241014'))\n    ) s2 on s1.vplayerid = s2.vplayerid and s1.ds = s2.ds and s2.dteventtime > s1.dteventtime\n    join (\n        select dtstatdate as ds, vplayerid, dteventtime\n        from dws_jordass_buttonpress_pre_di\n        where buttontype = 411123\n        and ((dtstatdate between '20240917' and '20240923') or (dtstatdate between '20241008' and '20241014'))\n    ) s3 on s2.vplayerid = s3.vplayerid and s2.ds = s3.ds and s3.dteventtime > s2.dteventtime\n)f \ngroup by ds;\n",
  "sql35": "Q:\"统计2024年3月26日~4月3日、2024年5月28日~6月5日，不同对局类型留存情况...\"\nSchema_links:[dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.mode,dws_jordass_mode_roundrecord_di.roundcnt,dws_jordass_mode_roundrecord_di.roundtime,dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid]\nA: Let's think step by step.\"统计不同对局类型留存\" 需要先解决子问题:\n\"每天每对局类型 每玩家 对局次数/时长是多少？\" 该问题由 round_user CTE 完成。\n然后在 main query 上同时 join 登录表(游戏层留存) 和 round_user 自身(玩法层留存)，以 date_add(dtstatdate,1) 判次留、date_add(dtstatdate,6) 判7留。\nIntermediate_representation: 使用 round_user CTE 聚合，再 left join 两次 login 与两次 round_user。\nSQL:\n\nwith round_user as (\n    select dtstatdate,\n        case \n            when mode in (401,402,403) then '第一人称'\n            when mode =101 then '单排'\n            when mode =102 then '双排'\n            when mode in (103,603) then '四排'\n        end modename,\n        vplayerid,\n        sum(roundcnt) roundcnt,\n        sum(roundtime) roundtime\n    from dws_jordass_mode_roundrecord_di\n    where ((dtstatdate between '20240326' and '20240409')\n    or (dtstatdate between '20240528' and '20240611'))\n    and mode in (401,402,403,101,102,103,603)\n    group by dtstatdate,\n    case when mode in (401,402,403) then '第一人称'\n        when mode =101 then '单排'\n        when mode =102 then '双排'\n        when mode in (103,603) then '四排'\n    end,\n    vplayerid\n)\n\nselect \n    a.dtstatdate,\n    a.modename,\n    count(distinct a.vplayerid) iusernum,\n    sum(a.roundcnt) roundcnt,\n    sum(a.roundtime) roundtime,\n    count(distinct b1.vplayerid) stay2,\n    count(distinct b2.vplayerid) stay7,\n    count(distinct c1.vplayerid) playstay2,\n    count(distinct c2.vplayerid) playstay7\nfrom (\n    select * from round_user \n    where((dtstatdate between '20240326' and '20240403') or (dtstatdate between '20240528' and '20240605'))\n) a\nleft join (\n    select dtstatdate,vplayerid \n    from dws_jordass_login_di\n    where ((dtstatdate between '20240326' and '20240404') or (dtstatdate between '20240528' and '20240606')) \n    and platid =255\n    group by dtstatdate,vplayerid\n) b1 \non a.vplayerid = b1.vplayerid and date_add(a.dtstatdate,1) = b1.dtstatdate\nleft join (\n    select dtstatdate,vplayerid \n    from dws_jordass_login_di\n    where ((dtstatdate between '20240326' and '20240409') or (dtstatdate between '20240528' and '20240611')) and platid =255\n    group by dtstatdate,vplayerid\n) b2 \non a.vplayerid = b2.vplayerid and date_add(a.dtstatdate,6) = b2.dtstatdate\nleft join round_user c1 \non a.vplayerid = c1.vplayerid and date_add(a.dtstatdate,1) = c1.dtstatdate and a.modename= c1.modename\nleft join round_user c2 \non a.vplayerid = c2.vplayerid and date_add(a.dtstatdate,6) = c2.dtstatdate and a.modename= c2.modename\ngroup by a.dtstatdate,a.modename\n;",
  "sql37": "Q: \"统计注册日期在2025.4.1-2025.5.30的模拟器新进用户在用户类型(模拟器、手机端、整体砺刃游戏内)，次留、三留、七留、14留、30留情况\n输出:日期(20250401、...、20250530)、人数、用户类型(模拟器、手机端、游戏内、未知)、次留人数、三留人数、七留人数、14留人数、30留人数\"\nSchema_links: [dws_jordass_emulator_df.dregdate,dws_jordass_emulator_df.vplayerid,dws_jordass_emulator_df.dtstatdate,dws_jordass_emulator_df.platid,dws_jordass_device_login_di.dtstatdate,dws_jordass_device_login_di.vplayerid,dws_jordass_device_login_di.device_type,dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid,dws_jordass_login_di.platid]\nA: Let's think step by step. 为了解决该问题，我们需要回答两个子问题:\n1) 对于每个注册日期(2025-04-01 到 2025-05-30)，有哪些模拟器新进用户(cohort)？\n2) 在 cohort 对应的后续天(次留=+1天、三留=+2天、七留=+6天、14留=+13天、30留=+29天)中，这些用户在三类登录来源(手机端/模拟器/游戏内)中分别有哪些人有行为？\n\n子问题1 的 SQL(cohort 提取):\n\nselect \n    f1.dregdate as ds,  -- 注册日期作为 cohort 日期\n    f1.vplayerid as vplayerid\nfrom dws_jordass_emulator_df f1\nwhere f1.dtstatdate = '20251001'  -- 基准统计日期(从 knowledge 中给出)\n  and f1.dregdate >= '20250401'\n  and f1.dregdate <= '20250530'\n  and f1.platid = 255  -- 限制平台为模拟器数据(根据 knowledge)\n\n子问题2 的 SQL(行为并集 s2，用于判断后续天是否有行为):\n\nselect \n    f1.dtstatdate as ds,\n    f1.vplayerid as vplayerid,\n    '手机端' as user_type\nfrom dws_jordass_device_login_di f1\nwhere f1.device_type = 0\n  and f1.dtstatdate >= '20250401' and f1.dtstatdate <= date_add('20250530', 29)\n\nunion all\n\nselect \n    f1.dtstatdate as ds,\n    f1.vplayerid as vplayerid,\n    '模拟器' as user_type\nfrom dws_jordass_device_login_di f1\nwhere f1.device_type in (1,5)\n  and f1.dtstatdate >= '20250401' and f1.dtstatdate <= date_add('20250530', 29)\n\nunion all\n\nselect \n    f1.dtstatdate as ds,\n    f1.vplayerid as vplayerid,\n    '游戏内' as user_type\nfrom dws_jordass_login_di f1\nwhere f1.dtstatdate >= '20250401' and f1.dtstatdate <= date_add('20250530', 29)\n  and f1.platid = 255;\n\n\nIntermediate_representation: 使用两个派生表(s1: cohort，即 emulator 表中注册日期在 20250401~20250530 且 dtstatdate=20251001 的用户；s2: 行为表，为 device_login 与 login 表的 union，标注 user_type)，然后 s1 LEFT JOIN s2 (按 vplayerid)，并在聚合时通过 conditional distinct count 判断 s2.ds 是否等于 date_add(s1.ds, N) 来计算次留/三留/七留/14留/30留。最终按 s1.ds(cohort 日期)与 user_type 聚合输出。\n\n最终 SQL:\n\nselect \n    s1.ds as `ds`, -- 日期\n    count(distinct s1.vplayerid) as `user_cnt`, -- 人数\n    coalesce(user_type, '未知') as `user_type`, -- 用户类型\n    count(distinct case when s2.ds = date_add(s1.ds, 1) then s1.vplayerid else null end) as `next_day_retention`, -- 次留人数\n    count(distinct case when s2.ds = date_add(s1.ds, 2) then s1.vplayerid else null end) as `three_day_retention`, -- 三留人数\n    count(distinct case when s2.ds = date_add(s1.ds, 6) then s1.vplayerid else null end) as `seven_day_retention`, -- 七留人数\n    count(distinct case when s2.ds = date_add(s1.ds, 13) then s1.vplayerid else null end) as `fourteen_day_retention`, -- 14留人数\n    count(distinct case when s2.ds = date_add(s1.ds, 29) then s1.vplayerid else null end) as `thirty_day_retention` -- 30留人数\nfrom (\n    select \n        f1.dregdate as ds,  -- 日期\n        f1.vplayerid as vplayerid  -- 用户id\n    from  dws_jordass_emulator_df f1\n    where   f1.dtstatdate = '20251001'  \n        and f1.dregdate >= '20250401'  \n        and f1.dregdate <= '20250530'  \n        and f1.platid = 255  \n) s1\nleft join (\n    select \n        f1.dtstatdate as ds, -- 统计日期\n        f1.vplayerid as vplayerid, -- 手机端登录用户id\n        '手机端' as user_type\n    from  dws_jordass_device_login_di f1\n    where  f1.device_type=0 -- 手机端\n    and f1.dtstatdate >= '20250401' and f1.dtstatdate <= date_add('20250530', 29)\n\n    union all\n\n    select \n        f1.dtstatdate as ds, -- 统计日期\n        f1.vplayerid as vplayerid, -- 手机端登录用户id\n        '模拟器' as user_type\n    from  dws_jordass_device_login_di f1\n    where  f1.device_type in (1,5) -- 模拟器\n    and f1.dtstatdate >= '20250401' and f1.dtstatdate <= date_add('20250530', 29)\n\n    union all\n\n    select \n        f1.dtstatdate as ds,  -- 日期\n        f1.vplayerid as vplayerid,  -- 整体游戏内登录用户id\n        '游戏内' as user_type\n    from   dws_jordass_login_di f1  \n    where  f1.dtstatdate >= '20250401' and f1.dtstatdate <= date_add('20250530', 29)\n    and f1.platid = 255  -- 不区分系统平台\n) s2 \n    on   s1.vplayerid = s2.vplayerid\n    group by   s1.ds, user_type\n;\n",
  "sql38": "Q: \"统计不同玩法不同用户类型的参与情况\n\n输出:玩法、用户类型(砺刃新增、砺刃回流(流失60天以上)、砺刃回流(流失21-59天)、砺刃回流(流失14-20天)、砺刃回流(流失7-13天)、砺刃留存、平台盘内、平台盘外)、上线后3天参与用户数、上线后3天总用户数\n\n各玩法上线日期:\n\"广域战场\": \"20240723\",\n\"消灭战\": \"20230804\",\n\"幻想混战\": \"20241115\",\n\"荒野传说\": \"20240903\",\n\"策略载具\": \"20241010\",\n\"炎夏混战\": \"20240625\",\n\"单人装备\": \"20240517\",\n\"交叉堡垒\": \"20240412\"\"\nSchema_links: [dws_jordass_login_df.dtstatdate,dws_jordass_login_df.dregdate,dws_jordass_login_df.vplayerid,dws_jordass_login_df.cbitmap,dws_mgamejp_login_user_activity_di.dtstatdate,dws_mgamejp_login_user_activity_di.suserid,dws_mgamejp_login_user_activity_di.sgamecode,dws_mgamejp_login_user_activity_di.saccounttype,dws_mgamejp_login_user_activity_di.splattype,dws_mgamejp_login_user_activity_di.splat,dim_jordass_playerid2suserid_nf.vplayerid,dim_jordass_playerid2suserid_nf.suserid,dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename]\nA: Let's think step by step. 为了解决该问题，我们把整体任务拆成明确的子问题，并给出相应子查询/CTE:\n\n子问题与对应子查询/CTE:\n\n1) 在每个玩法上线后第3天抽取用户基础信息(用于判定新增/回流/留存)。\nCTE `usertype`(示例):\n\n```\nwith usertype as (\n    select '广域战场' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20240723',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    ... -- 针对每个玩法分别取上线日+2 的 dws_jordass_login_df 记录(保持 platid=255 与 cbitmap 判定)\n)\n```\n\n2) 判定上线前一周是否在平台大盘活跃(用于判断平台盘内/盘外)。\nCTE `dapan`(示例):\n\n```\ndapan as (\n    select '广域战场' itype, suserid, max(case when sgamecode='jordass' then 1 else 0 end) flag1\n    from dws_mgamejp_login_user_activity_di\n    where dtstatdate >= cast(date_format(date_sub('20240723',7), '%Y%m%d') as bigint)\n      and dtstatdate <= cast(date_format(date_sub('20240723',1), '%Y%m%d') as bigint)\n      and saccounttype ='-100'\n      and sgamecode <>'-100'\n      and splattype = '-100'\n      and splat = '-100'\n    group by suserid\n    union all\n    ... -- 针对每个玩法重复相同逻辑\n)\n```\n\n3) 将平台 suserid 映射为游戏 vplayerid(dim 表)，得到 dapan2jordass:\n\n```\ndapan2jordass as (\n    select distinct itype, b.vplayerid, flag1\n    from dapan a\n    join (\n        select vplayerid,suserid from dim_jordass_playerid2suserid_nf\n    ) b on a.suserid = b.suserid\n)\n```\n\n4) 抽取各玩法上线后3天(上线日到上线日+2)首次参与玩法的玩家，作为 playuser:\n\n```\nplayuser as (\n    select '广域战场' itype, min(dtstatdate) dtstatdate, vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240723' and dtstatdate <= date_add('20240723',2) and submodename= '广域战场模式'\n    group by vplayerid\n    union all\n    ... -- 为每个玩法分别取上线日到上线日+2 的 min(dtstatdate) & vplayerid\n)\n```\n\n5) 基于 `usertype` 的 dregdate 与 cbitmap(以及 dtstatdate)划分用户类型标签(砺刃新增/留存/回流各区间)，并结合 dapan2jordass 判平台盘内/盘外。\n关键判定逻辑(简述):\n - 砺刃新增:datediff(dtstatdate, dregdate) <= 2(上线后3天内为新增)\n - 砺刃留存 / 回流:依据 cbitmap 中某字段(示例用 substr/ instr 的方式)判断上线前 N 天的活跃/未活跃距离，从而区分流失区间:<=7、(7,13], [14,20], [21,59], >=60\n - 平台盘内/盘外:依据 dapan2jordass 中 flag1 判定(flag1=0 表示平台盘内，但未在砺刃活跃)，若在 dapan 中无映射则为平台盘外\n\nIntermediate_representation: 使用多个 CTE:\n - usertype(每玩法上线后第3天的用户基础与 cbitmap)\n - dapan(平台大盘上线前一周活跃判定)\n - dapan2jordass(suserid->vplayerid 映射后用于判盘内/盘外)\n - playuser(每玩法上线后3天内首次参与玩法的玩家)\n 然后:\n - playuser 与 usertype join 得到按玩法+用户类型的参与人数(iusernum1)，并通过 left join dapan2jordass 判盘内/盘外；\n - 同时对 usertype 做 group by 得到各玩法各分类的总人数(iusernum2)；\n - 最终将两部分 join 汇总为输出(玩法、用户类型、上线后3天参与用户数、上线后3天总用户数)。\n\n最终 SQL:\n\n```\nwith usertype as (\n    select '广域战场' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20240723',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '消灭战' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20230804',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '幻想混战' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20241115',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '荒野传说' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20240903',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '策略载具' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20241010',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '炎夏混战' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20240625',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '单人装备' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20240517',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n    union all\n    select '交叉堡垒' itype, dtstatdate, dregdate, vplayerid, cbitmap \n    from dws_jordass_login_df\n    where dtstatdate = date_add('20240412',2) and platid =255 and instr(substr(cbitmap,1,3),'1')>0\n),\n dapan as (\n    select '广域战场' itype, suserid, max(case when sgamecode='jordass' then 1 else 0 end) flag1\n    from dws_mgamejp_login_user_activity_di\n    where dtstatdate >= cast(date_format(date_sub('20240723',7), '%Y%m%d') as bigint) and dtstatdate <= cast(date_format(date_sub('20240723',1), '%Y%m%d') as bigint)\n        and saccounttype ='-100'\n        and sgamecode <>'-100'\n        and splattype = '-100'\n        and splat = '-100'\n    group by suserid\n    union all\n    -- ... 每个玩法重复相同逻辑\n),\n dapan2jordass as (\n    select distinct itype, b.vplayerid, flag1\n    from dapan a\n    join (\n        select vplayerid,suserid from dim_jordass_playerid2suserid_nf\n    ) b on a.suserid = b.suserid\n),\n playuser as (\n    select '广域战场' itype, min(dtstatdate) dtstatdate, vplayerid\n    from dws_jordass_mode_roundrecord_di\n    where dtstatdate >= '20240723' and dtstatdate <= date_add('20240723',2) and submodename= '广域战场模式'\n    group by vplayerid\n    union all\n    -- ... 每个玩法重复相同逻辑\n)\n\nselect \n    t.itype,\n    t.user_type,\n    t.iusernum1,\n    p.iusernum2\nfrom (\n    select \n        a.itype,\n        b.user_type,\n        count(distinct a.vplayerid) iusernum1\n    from playuser a\n    join (\n        select \n            itype, vplayerid,\n            case \n                when datediff(dtstatdate,dregdate)<=2 then '砺刃新增'\n                when instr(substr(cbitmap,4),'1')=0 or instr(substr(cbitmap,4),'1')>=60 then '砺刃回流(流失60天以上)'\n                when instr(substr(cbitmap,4),'1')>=21 then '砺刃回流(流失21-59天)'\n                when instr(substr(cbitmap,4),'1')>=14 then '砺刃回流(流失14-20天)'\n                when instr(substr(cbitmap,4),'1')>7 then '砺刃回流(流失7-13天)'\n                when instr(substr(cbitmap,4),'1')<=7 then '砺刃留存' \n            end user_type\n        from usertype\n    ) b on a.itype = b.itype and a.vplayerid = b.vplayerid\n    group by a.itype,b.user_type\n\n    union all\n    \n    select \n        a.itype, \n        case \n            when flag1=0 then '平台盘内' \n            when b.vplayerid is null then '平台盘外' \n        end user_type, \n    count(distinct a.vplayerid) iusernum1\n    from playuser a\n    left join dapan2jordass b \n    on a.itype = b.itype and a.vplayerid = b.vplayerid\n    where flag1=0 or b.vplayerid is null\n    group by a.itype, case when flag1=0 then '平台盘内' when b.vplayerid is null then '平台盘外' end\n) t\nleft join (\n    select itype,\n        case \n            when datediff(dtstatdate,dregdate)<=2 then '砺刃新增'\n            when instr(substr(cbitmap,4),'1')=0 or instr(substr(cbitmap,4),'1')>=60 then '砺刃回流(流失60天以上)'\n            when instr(substr(cbitmap,4),'1')>=21 then '砺刃回流(流失21-59天)'\n            when instr(substr(cbitmap,4),'1')>=14 then '砺刃回流(流失14-20天)'\n            when instr(substr(cbitmap,4),'1')>7 then '砺刃回流(流失7-13天)'\n            when instr(substr(cbitmap,4),'1')<=7 then '砺刃留存' \n        end user_type,\n        count(distinct vplayerid) iusernum2\n    from usertype\n    group by itype,\n        case \n            when datediff(dtstatdate,dregdate)<=2 then '砺刃新增'\n            when instr(substr(cbitmap,4),'1')=0 or instr(substr(cbitmap,4),'1')>=60 then '砺刃回流(流失60天以上)'\n            when instr(substr(cbitmap,4),'1')>=21 then '砺刃回流(流失21-59天)'\n            when instr(substr(cbitmap,4),'1')>=14 then '砺刃回流(流失14-20天)'\n            when instr(substr(cbitmap,4),'1')>7 then '砺刃回流(流失7-13天)'\n            when instr(substr(cbitmap,4),'1')<=7 then '砺刃留存' \n        end\n\n    union all\n\n    select itype,'平台盘内',count(distinct vplayerid) \n    from dapan2jordass \n    group by itype\n) p on t.itype=p.itype and t.user_type=p.user_type\n;",
  "sql39": "Q: \"\n统计各个玩法参与用户其他玩法流入和双栖情况\n\n输出:流入玩法、流出玩法、上线后3天流入玩法参与用户数、上线后3天流出用户数、上线后3天双栖用户数、上线前一周流出玩法总参与用户数、流出占比、上线后3天流出玩法总参与用户数、双栖占比\n\",\nSchema_links: [dws_jordass_mode_roundrecord_di.dtstatdate,dws_jordass_mode_roundrecord_di.vplayerid,dws_jordass_mode_roundrecord_di.submodename,dws_jordass_mode_roundrecord_di.modename,dws_jordass_mode_roundrecord_di.mapname,dws_jordass_mode_roundrecord_di.submode]\nA: Let's think step by step. 要构建该分析，需要回答的核心子问题为:\n1) 每个流入玩法上线日及上线后3天内哪些玩家参与了该流入玩法？ (构造 playuser)\n2) 对于每种流入玩法，如何把用户在上线前7天到上线后3天的行为映射到‘流出玩法’分类，并打标该玩家上线前是否玩过(islast)与上线后是否玩过(isthis)？(构造 allplayuser)\n3) 在 playuser 与 allplayuser 的联表基础上，如何计算流入玩法的参与人数、流出用户数、双栖用户数，以及流出玩法在上线前/上线后窗口的总参与数并计算占比？\n\nIntermediate_representation: 使用两个 CTE:\n- playuser:按流入玩法上线日取上线日到上线日+2 的玩家集合(各玩法用 UNION ALL 分别筛选并打上 itype 标签)；\n- allplayuser:对每个流入玩法构造一个从上线日前7天到上线日+2 的玩家-玩法映射，并用 CASE 将 modename/submodename/mapname 映射为 playclass1(流出玩法)；同时计算 islast(上线日前有无参与)和 isthis(上线日及后3天有无参与)的标记。\n基于上述两表:\n- 计算流入玩法总体参与数(p:按 itype count(distinct vplayerid))；\n- 联表统计流出用户数(iusernum2:islast=1 and isthis=0) 与 双栖用户数(iusernum3:islast=1 and isthis=1)；\n- 从 allplayuser 汇总得到上线前一周流出玩法总参与(iusernum4) 与 上线后3天流出玩法总参与(iusernum5)，用于计算占比。\n\nSQL:\n\nwith playuser as (\n select '广域战场' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate= '20240723' and date_add('20240723',2) and submodename= '广域战场模式'\n group by 1,2,3\n union all\n select '消灭战' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20230804' and date_add('20230804',2) and modename='组队竞技' and submodename like '%消灭战模式%'\n group by 1,2,3\n union all\n select '幻想混战' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20241115' and date_add('20241115',2) and modename='创意创作间' and submodename='幻想混战'\n group by 1,2,3\n union all\n select '荒野传说' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20240903' and date_add('20240903',2) and modename='休闲模式' and submodename in ('荒野传说','荒野沙漠')\n group by 1,2,3\n union all\n select '策略载具' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20241010' and date_add('20241010',2) and modename='休闲模式' and submodename like '%策略载具%'\n group by 1,2,3\n union all\n select '炎夏混战' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20240625' and date_add('20240625',2) and modename='创意创作间' and submodename like '%炎夏混战%'\n group by 1,2,3\n union all\n select '单人装备' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20240517' and date_add('20240517',2) and modename='组队竞技' and submodename like '%单人装备%'\n group by 1,2,3\n union all\n select '交叉堡垒' itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20240412' and date_add('20240412',2) and modename='组队竞技' and submodename like '%交叉堡垒%'\n group by 1,2,3\n union all\n select '庆典混战' as itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20240426' and date_add('20240426',2) and submode in (2611)\n group by dtstatdate,vplayerid\n union all\n select 'CG29-流浪地球' as itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20240903' and date_add('20240903',2)and submodename = 'CG29-流浪地球'\n group by dtstatdate,vplayerid\n union all\n select 'CG28-动物丛林' as itype,dtstatdate,vplayerid\n from dws_jordass_mode_roundrecord_di\n where dtstatdate = '20241105' and date_add('20241105',2)and submodename = 'CG28-动物丛林'\n group by dtstatdate,vplayerid\n),\nallplayuser as (\n select '广域战场' itype,\n case \n when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240723' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240723' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240723',7) and dtstatdate <= date_add('20240723',2) \n group by \n case \n when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '消灭战' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20230804' then 1 else 0 end) islast,\n max(case when dtstatdate>='20230804' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20230804',7) and dtstatdate <= date_add('20230804',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '幻想混战' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20241115' then 1 else 0 end) islast,\n max(case when dtstatdate>='20241115' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20241115',7) and dtstatdate <= date_add('20241115',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '荒野传说' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240903' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240903' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240903',7) and dtstatdate <= date_add('20240903',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '策略载具' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20241010' then 1 else 0 end) islast,\n max(case when dtstatdate>='20241010' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20241010',7) and dtstatdate <= date_add('20241010',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '炎夏混战' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240625' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240625' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240625',7) and dtstatdate <= date_add('20240625',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '单人装备' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240517' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240517' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240517',7) and dtstatdate <= date_add('20240517',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '交叉堡垒' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240412' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240412' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240412',7) and dtstatdate <= date_add('20240412',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select '庆典混战' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240426' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240426' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240426',7) and dtstatdate <= date_add('20240426',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select 'CG28-动物丛林' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20240903' then 1 else 0 end) islast,\n max(case when dtstatdate>='20240903' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20240903',7) and dtstatdate <= date_add('20240903',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n union all\n select 'CG29-流浪地球' itype,\n case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end playclass1,\n vplayerid,\n max(case when dtstatdate<'20241105' then 1 else 0 end) islast,\n max(case when dtstatdate>='20241105' then 1 else 0 end) isthis\n from dws_jordass_mode_roundrecord_di\n where dtstatdate >= date_sub('20241105',7) and dtstatdate <= date_add('20241105',2) \n group by case when modename='传统模式' and submodename like 'CG%' and mapname='群屿' then '主题群屿'\n when modename='传统模式' and mapname='群屿' then '传统群屿'\n when modename='传统模式' and mapname='假日群岛' then '假日群岛'\n when modename='传统模式' and mapname='山峦' then '山峦'\n when submodename='极能形态模式' then '极能形态模式'\n when modename='生存模式' then '隧道'\n when submodename='广域战场模式' then '广域战场'\n when modename in ('休闲模式','乐园','领地','广阔天地','组队竞技') then modename\n else '其他子模式'\n end ,\n vplayerid\n)\n\nselect \n t.itype, \n t.playclass1, \n iusernum1, -- 流入玩法参与用户数\n iusernum2, -- 流出用户数\n iusernum3, -- 双栖用户数\n iusernum4, -- 前一周流出玩法用户数\n coalesce(round(iusernum2/iusernum4, 2), 0) as ratio1, -- 流出占比\n iusernum5, -- 后3天流出玩法用户数\n coalesce(round(iusernum3/iusernum5, 2), 0) as ratio2 -- 双栖占比\nfrom (\n select itype,count(distinct vplayerid) iusernum1 from playuser group by itype\n)p\nleft join (\n select \n a.itype,\n b.playclass1,\n count(distinct case when islast=1 and isthis =0 then a.vplayerid end) iusernum2,\n count(distinct case when islast=1 and isthis =1 then a.vplayerid end) iusernum3\n from playuser a\n left join allplayuser b \n on a.itype =b.itype and a.vplayerid = b.vplayerid\n group by a.itype,b.playclass1\n)t on p.itype = t.itype\nleft join (\n select \n itype, \n playclass1,\n count(distinct case when islast=1 then vplayerid end) iusernum4,\n count(distinct case when isthis=1 then vplayerid end) iusernum5\n from allplayuser\n group by itype,playclass1\n) m on t.playclass1=m.playclass1 and t.itype=m.itype\n;",
  "sql45": "Q: \"统计2024.01.01-2024.01.07参与乐园子玩法拼图狂欢在202401.08-2024.01.14没玩乐园子玩法拼图狂欢在2024.01.15-2024.01.21又玩了乐园子玩法拼图狂欢的用户\n输出:玩家数\"\nSchema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_matchlog_stat_di.imode]\nA: Let's think step by step. 要解决这个问题，需要以下子问题的答案:\n1) 在 2024-01-01 到 2024-01-07 期间，哪些玩家玩了 imode = 1287652322611036928？\n2) 在 2024-01-08 到 2024-01-14 期间，哪些玩家玩了该 imode？\n3) 在 2024-01-15 到 2024-01-21 期间，哪些玩家玩了该 imode？\n\n第一个子问题的 SQL 为:\n\nselect distinct vplayerid\nfrom dws_jordass_matchlog_stat_di\nwhere dtstatdate between '20240101' and '20240107'\nand imode = 1287652322611036928;\n\n第二个子问题的 SQL 为:\n\nselect distinct vplayerid\nfrom dws_jordass_matchlog_stat_di\nwhere dtstatdate between '20240108' and '20240114'\nand imode = 1287652322611036928;\n\n第三个子问题的 SQL 为:\n\nselect distinct vplayerid\nfrom dws_jordass_matchlog_stat_di\nwhere dtstatdate between '20240115' and '20240121'\nand imode = 1287652322611036928;\n\nIntermediate_representation: 使用三个派生表 a(首周)、b(次周)、c(第三周):先把首周玩家作为基准，左连接次周并筛除在次周出现的玩家(b.vplayerid is null)，再与第三周做内连接以确保这些玩家在第三周又出现，最后统计 distinct 玩家数。\n\nSQL:\n\nselect count(distinct a.vplayerid) as player_num\nfrom (\n select distinct vplayerid\n from dws_jordass_matchlog_stat_di\n where dtstatdate between '20240101' and '20240107'\n and imode = 1287652322611036928\n) a\nleft join (\n select distinct vplayerid\n from dws_jordass_matchlog_stat_di\n where dtstatdate between '20240108' and '20240114'\n and imode = 1287652322611036928\n) b on a.vplayerid = b.vplayerid\njoin (\n select distinct vplayerid\n from dws_jordass_matchlog_stat_di\n where dtstatdate between '20240115' and '20240121'\n and imode = 1287652322611036928\n) c on a.vplayerid = c.vplayerid\nwhere b.vplayerid is null;",
  "sql46": "Q: \"统计2024.1.1-2024.2.2期间，每个自然周不同周活跃天数玩家数\n输出:统计周(1、2、3...、5)、周活跃天数、玩家数\"\nSchema_links: [dws_jordass_login_di.dtstatdate,dws_jordass_login_di.vplayerid,dws_jordass_login_di.platid]\nA: Let's think step by step. 为了回答“统计每个自然周不同周活跃天数玩家数”，我们需要先回答子问题:\n- 子问题1:对于每个玩家与每个自然周，周内的活跃天数(去重 dtstatdate)是多少？\n- 子问题2:基于子问题1 的结果，按周与活跃天数统计玩家数。\n\n子问题1 的 SQL(派生表 f):\n\nselect\n vplayerid, -- 玩家playerid\n weekofyear(dtstatdate) as week, -- 统计周\n count(distinct dtstatdate) as active_days -- 活跃天数\nfrom dws_jordass_login_di\nwhere dtstatdate >= '20240101' and dtstatdate <= '20240202' and platid=255\ngroup by\n vplayerid,\n weekofyear(dtstatdate);\n\n中间表示(Intermediate_representation):先对 dws_jordass_login_di 按玩家与 weekofyear 聚合得到每玩家每周的活跃天数(active_days)，作为派生表 f；再对 f 按 week 与 active_days 聚合计数不同玩家数。\n\n最终 SQL:\n\nselect\n week, -- 统计周\n active_days, -- 活跃天数\n count(distinct vplayerid) as user_num -- 玩家数\nfrom (\n select\n vplayerid, -- 玩家playerid\n weekofyear(dtstatdate) as week, -- 统计周\n count(distinct dtstatdate) as active_days -- 活跃天数\n from dws_jordass_login_di\n where dtstatdate >= '20240101' and dtstatdate <= '20240202' and platid=255\n group by\n vplayerid,\n weekofyear(dtstatdate)\n)f\ngroup by\n week,\n active_days;",
  "sql48": "Q: \"统计2023.12.1流失7天的回流用户数和流失30天的回流用户数\n输出：流失7天的回流用户数，流失30天的回流用户数\"\nSchema_links: [dws_jordass_login_df.vplayerid,dws_jordass_login_df.dregdate,dws_jordass_login_df.dtstatdate,dws_jordass_login_df.cbitmap]\nA: Let's think step by step. \"统计2023.12.1流失7天的回流用户数和流失30天的回流用户数\" can be solved by knowing the answer to the following sub-questions \"对于每个玩家，如何判断流失7天回流？\" 和 \"对于每个玩家，如何判断流失30天回流？\".\nThe SQL query for the sub-question \"对于每个玩家，如何判断流失7天回流？\" is:\n\nselect\n    vplayerid,\n    (dregdate <> dtstatdate) and\n    (instr(substr(cbitmap, 1, 1), '1') > 0) and\n    (instr(substr(cbitmap, 2, 7), '1') = 0) as is_backflow_7\nfrom dws_jordass_login_df\nwhere dtstatdate='20231201' and platid=255;\n\nSo, the answer to the question \"统计2023.12.1流失7天的回流用户数和流失30天的回流用户数\" is =\nIntermediate_representation: 对同一个来源表做一层派生，计算两种 boolean flag，然后外层 count distinct\nSQL:\n\nselect\n    count(distinct case when is_backflow_7 then vplayerid end) as backflow_7_user,\n    count(distinct case when is_backflow_30 then vplayerid end) as backflow_30_user\nfrom (\n    select\n        vplayerid,\n        -- 检查是否满足流失7天回流条件\n        (dregdate <> dtstatdate) and\n        (instr(substr(cbitmap, 1, 1), '1') > 0) and\n        (instr(substr(cbitmap, 2, 7), '1') = 0) as is_backflow_7,\n        \n        -- 检查是否满足流失30天回流条件\n        (dregdate <> dtstatdate) and\n        (instr(substr(cbitmap, 1, 1), '1') > 0) and\n        (instr(substr(cbitmap, 2, 30), '1') = 0) as is_backflow_30\n    from\n        dws_jordass_login_df\n    where\n        dtstatdate = '20231201'\n        and platid = 255\n) as user_flags;",
  "sql49": "Q: \"2024年10月1-2024年10月7 用周期开始时间判断玩法上线时间在7天及以上，周期结束时间判断玩法上线时间在90天及以内的玩法，统计周期内这些玩法的参与和留存情况\n输出：周期(20241001-20241007)，日期(20241001、...、20241007)，参与人数，次留人数\"\nSchema_links: [dws_jordass_matchlog_stat_di.dtstatdate,dws_jordass_matchlog_stat_di.vplayerid,dws_jordass_matchlog_stat_di.imode,dim_jordass_submodeonline_nf.matchsubmodegroup,dim_jordass_submodeonline_nf.onlinedate]\nA: Let's think step by step. \"统计周期内这些玩法的参与和留存情况\" 可拆成 \"先挑出满足上线限制的玩法玩家在周期日粒度的 distinct list\" 与 \"同player是否在ds+1 仍出现\"。\nThe SQL query for the sub-question \"哪些玩家在满足筛选条件的玩法中 20241001~20241008 内每天参与？\" 是 play_user 这个 CTE。\nSo, the answer to the question \"2024年10月1-2024年10月7 ...参与和留存\" is =\nIntermediate_representation: 使用一个 CTE 产生满足上线窗口的玩法的日 x player 参与表，再 self left join 实现 T+1 次留统计。\nSQL:\n\nwith play_user as (\n    select distinct\n        p.dtstatdate as ds, --日期\n        p.vplayerid    --玩家id\n    from\n        dws_jordass_matchlog_stat_di p\n    join\n        dim_jordass_submodeonline_nf c\n    on\n        p.imode = c.matchsubmodegroup\n    where\n        p.dtstatdate between '20241001' and '20241008'\n        and datediff('20241001', c.onlinedate) >= 7\n        and datediff('20241007', c.onlinedate) <= 90\n)\nselect\n    '20241001-20241007' as period, --周期\n    a.ds,\n    count(distinct a.vplayerid) as play_user_num, --参与人数\n    count(distinct b.vplayerid) as retention_user_num --次留人数\nfrom\n    play_user a\nleft join\n    play_user b\non\n    a.vplayerid = b.vplayerid\n    and b.ds = date_add(a.ds, 1)  -- 次日留存条件\nwhere\n    a.ds between '20241001' and '20241007'\ngroup by\n    a.ds\norder by\n    a.ds;",
  "sql56": "Q: \"时间：2024.01.01-2024.01.31\n每日新增用户的LTV，LTV1~LTV10\n输出：注册日期(20240101、20240102、...、20240131)、新进用户数、LTV1、LTV3、LTV7、LTV14、LTV30、LTV60、LTV90、LTV180\"\nSchema_links: [dws_jordass_login_df.dregdate,dws_jordass_login_df.dtstatdate,dws_jordass_login_df.vplayerid,dws_jordass_water_di.dtstatdate,dws_jordass_water_di.vplayerid,dws_jordass_water_di.imoney]\nA: Let's think step by step. \"每日新增用户LTV\" = 对每个注册日 cohort 的平均付费额累积。要先知道：当天新增哪批用户（这个来自 login 表，按 dregdate），然后把这批用户之后 180 天所有付费行为 join 上来，然后算注册日与付费日的 datediff，然后做各个 LTV 窗口（N 表示从注册日算起 N 天内）。\n所以可以拆成两个派生小问题：\n1）s1：取 2024-01-01~2024-01-31 每天的新增用户（distinct 注册日 + uid）  —— 来源 dws_jordass_login_df，只取 dtstatdate=月底快照，是合理的用户 master。\n2）s2：取所有 uid 的每日付费（金额汇总）并转元，从 1月1 到 1月31+179天 —— 来源 dws_jordass_water_di。\n然后把 s1 left join s2 用 uid 接上，再计算 datediff(pay_date, register_date) 作为该笔付费相对注册的 day-index。\n内部 base 子表再按 register_date, vplayerid, pay_date group 是为了：一个用户一天多笔付费先合并。\n然后外层全部再按 register_date group，就能：\n  sum(case when diff<1 then pay) / 新增人数 => ltv1\n  sum(case when diff<3 then pay) / 新增人数 => ltv3\n  ...\n最终 = 一个派生表 base + 一层外部聚合。\nIntermediate_representation: 构造：s1(注册 cohort) × left join s2(付费行为) → 做 datediff → 再按注册日 group 输出多个 LTV 列。\nSQL:\n\nselect\n    register_date,\n    count(distinct vplayerid) as new_user_cnt,\n    round(sum(case when datediff_pay < 1 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv1,\n    round(sum(case when datediff_pay < 3 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv3,\n    round(sum(case when datediff_pay < 7 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv7,\n    round(sum(case when datediff_pay < 14 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv14,\n    round(sum(case when datediff_pay < 30 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv30,\n    round(sum(case when datediff_pay < 60 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv60,\n    round(sum(case when datediff_pay < 90 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv90,\n    round(sum(case when datediff_pay < 180 then sum_pay_amount else 0 end) / count(distinct vplayerid), 2) as ltv180\nfrom (\n    select\n        s1.register_date,\n        s1.vplayerid,\n        s2.pay_date,\n        datediff(s2.pay_date, s1.register_date) as datediff_pay,\n        sum(s2.pay_amount) as sum_pay_amount\n    from (\n        select\n            distinct dregdate as register_date,\n            vplayerid\n        from dws_jordass_login_df\n        where dtstatdate = '20240131'\n          and platid = 255\n          and dregdate >= '20240101' and dregdate <= '20240131'\n    ) s1\n    left join (\n        select\n            dtstatdate as pay_date,\n            vplayerid,\n            sum(imoney/100) as pay_amount\n        from dws_jordass_water_di\n        where dtstatdate >= '20240101' and dtstatdate <= date_add('20240131', 179)\n          and platid = 255\n        group by dtstatdate, vplayerid\n    ) s2 on s1.vplayerid = s2.vplayerid\n    group by s1.register_date, s1.vplayerid, s2.pay_date\n) base\ngroup by register_date;",
  "sql57": "Q: \"统计限定抽取阶梯活动每天的pv和角色数\n活动日期\t2024.11.29-12.19\t\n输出：日期(20241129、...、20241219、汇总)、pv、uv\"\nSchema_links: [dwd_jordass_activitypress_hi.tdbank_imp_date,dwd_jordass_activitypress_hi.uid,dwd_jordass_activitypress_hi.ireason,dwd_jordass_activitypress_hi.buttontype,dwd_jordass_activitypress_hi.extarg1]\nA: Let's think step by step. \"统计限定抽取阶梯活动每天的pv和角色数\" can be solved by knowing:\nsub-question 1 = \"限定抽取阶梯活动每日 pv / uv 是多少？\"\nsub-question 2 = \"限定抽取阶梯活动整个区间总 pv / uv 是多少？\"\nSo final SQL = daily aggregation UNION ALL total aggregation.\n\nIntermediate_representation: 用一个 union all 拼接 按日统计 + 汇总\nSQL:\n\n-- 查询限定抽取阶梯活动相关数据\nselect\n    dtstatdate,\n    pv,\n    uv\nfrom (\n    -- 按天统计\n    select\n        substr(tdbank_imp_date, 1, 8) as dtstatdate,\n        count(*)                       as pv,\n        count(distinct uid)            as uv\n    from dwd_jordass_activitypress_hi\n    where tdbank_imp_date between '2024112900' and '2024121923'\n      and ireason   = 2411291018\n      and buttontype = 10045\n      and extarg1   in (117, 115)\n    group by substr(tdbank_imp_date, 1, 8)\n\n    union all\n\n    -- 汇总\n    select\n        '汇总' as dtstatdate,\n        count(*)            as pv,\n        count(distinct uid) as uv\n    from dwd_jordass_activitypress_hi\n    where tdbank_imp_date between '2024112900' and '2024121923'\n      and ireason   = 2411291018\n      and buttontype = 10045\n      and extarg1   in (117, 115)\n) f \n;\n",
  "sql59": "Q: \"统计：20250111-20250124时间区间内，幻境使者活动抽奖用户第X次触发赠送后，这些用户的总抽奖次数\n输出：第X次触发,触发用户数,用户总抽奖次数\"\nSchema_links: [dwd_jordass_activityrecord_hi.vplayerid,dwd_jordass_activityrecord_hi.tdbank_imp_date,dwd_jordass_activityrecord_hi.dteventtime,dwd_jordass_activityrecord_hi.actid,dwd_jordass_activityrecord_hi.acttype,dwd_jordass_activityrecord_hi.recodtype,dwd_jordass_activityrecord_hi.strarg1,dwd_jordass_activityrecord_hi.arg1]\nA: Let's think step by step. This question can be solved by knowing results of the sub-questions: \"哪些是触发赠送事件？(strarg1<>0)\", \"对于每个用户触发赠送事件的时间序列、它是第几次触发？(row_number)\", \"对于每个触发窗口（含自身不含下一次触发），累计 arg1 = 抽奖次数\". Then group by trigger_count.\nIntermediate_representation: 1) 派生表 s1: 每玩家触发赠送事件排序、row_number、next_event_time 2) 派生表 s2: 每玩家每event_time的抽奖次数(sum arg1) 3) 以 window join 计算窗口累计。\nSQL:\n\nselect \n    s1.trigger_count as `trigger_count`, -- 第x次触发\n    count(distinct s1.vplayerid) as `trigger_user_cnt`, -- 触发用户数\n    sum(s2.draw_count) as `total_draw_count` -- 用户总抽奖次数\nfrom (\n    select\n        vplayerid,\n        dteventtime,\n        coalesce(lead(dteventtime) over (partition by vplayerid order by dteventtime), '9999-12-31 23:59:59')  as next_dteventtime,\n        row_number() over (partition by vplayerid order by dteventtime) as trigger_count\n    from (\n        select distinct\n            vplayerid,\n            dteventtime\n        from dwd_jordass_activityrecord_hi\n        where tdbank_imp_date >= '2025011100'\n        and tdbank_imp_date <= '2025012423'\n        and actid = 2411070621\n        and acttype = 10062\n        and recodtype in ('1', '2')\n        and strarg1 <> '0'\n    ) ff1\n) s1 \njoin (\n    select\n        vplayerid,\n        dteventtime,\n        sum(arg1) as draw_count\n    from dwd_jordass_activityrecord_hi  -- actgeneralflow表\n    where tdbank_imp_date >= \"2025011100\" and tdbank_imp_date <= \"2025012423\" -- 时间区间：20250111-20250124\n    and actid = 2411070621\n    and acttype = 10062\n    and recodtype in (\"1\", \"2\")\n    group by vplayerid, dteventtime\n\n    \n) s2 \non s1.vplayerid = s2.vplayerid and s2. dteventtime >= s1.dteventtime and s2.dteventtime < s1.next_dteventtime\ngroup by s1.trigger_count\n"







}